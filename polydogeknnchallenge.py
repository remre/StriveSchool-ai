# -*- coding: utf-8 -*-
"""PolyDogeKNNChallenge.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/162dHdw-G6K2FZ8WIfdHc0kBRj534SZoh
"""

import numpy as np
from PIL import Image
import streamlit as st
import matplotlib.pyplot as plt
import pandas as pd
from sklearn.cluster import KMeans
import scipy.cluster.hierarchy as sch
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from sklearn.metrics import silhouette_score
from sklearn.preprocessing import MinMaxScaler
import plotly.graph_objects as go
from sklearn.model_selection import train_test_split
from sklearn.metrics import davies_bouldin_score

df = pd.read_csv('C:/Users/emrre/polydoge/CC_GENERAL.csv')

kk = df.sample(n=50)

df.isna().sum()

df['MINIMUM_PAYMENTS'].fillna((df['MINIMUM_PAYMENTS'].mean()), inplace=True)

df['CREDIT_LIMIT'].fillna((df['CREDIT_LIMIT'].mean()), inplace=True)

df.head()

points = df.iloc[:,1:]
pointss = points.values
type(points)

#df.skew()

df.isnull().sum()

corr = df.corr()
#plt.figure(figsize=(20, 15))
#matrix = np.triu(df.corr())
#sns.heatmap(corr,annot=True,fmt=".2",cmap= 'coolwarm',linewidths=2,square = True,mask = matrix)

points.columns

df4 = df.filter(["ONEOFF_PURCHASES","PURCHASES","PURCHASES_FREQUENCY", "PURCHASES_INSTALLMENTS_FREQUENCY","CASH_ADVANCE_FREQUENCY","CASH_ADVANCE_TRX"], axis=1)
df2 = df.filter(["PAYMENTS","MINIMUM_PAYMENTS","BALANCE_FREQUENCY", "BALANCE"], axis = 1)

#matrixx = np.triu(df4.corr())
#plt.figure(figsize=(7, 7))
#pp = sns.heatmap(df4.corr(),annot= True,mask = matrixx, cmap = "coolwarm", linewidths=2 )#square = True, linecolor = "white",

num_vars = ["ONEOFF_PURCHASES","PURCHASES","PURCHASES_FREQUENCY","PURCHASES_INSTALLMENTS_FREQUENCY","CASH_ADVANCE_FREQUENCY","CASH_ADVANCE_TRX"]
#for i in num_vars:
#    plt.figure(figsize=(16,1))
#    sns.boxplot(x=df[i])

pca = PCA() 
pcadf = pca.fit_transform(points) 
pcadf = pd.DataFrame(pcadf) 
pcadf.head()

X = points.copy()
X = np.nan_to_num(X)
Clust = StandardScaler().fit_transform(X)
Clust.shape

y = np.zeros(8950)
X_train, X_test, _, _ = train_test_split( X, y, test_size=0.2, random_state=0)

df[['BALANCE_FREQUENCY',
 'PURCHASES_FREQUENCY',
 'ONEOFF_PURCHASES_FREQUENCY',
 'PURCHASES_INSTALLMENTS_FREQUENCY',
 'CASH_ADVANCE_FREQUENCY',
'PRC_FULL_PAYMENT']].hist(figsize=(10,8))
#plt.tight_layout()

#import plotly.express as px
#fig = px.scatter_matrix(points,
#width=2000, height=3000)
#fig.show()

def kmeanss(k, X):
    fg, ax = plt.subplots(2, 2, figsize=(10, 7))
    sns.scatterplot(X[:, 0], X[:, 1], ax=ax[0, 0])
    '''
    given an input k, returns the model trained on k and the data
    to plot the inertia in the interval around +- 3
    '''
    if k > 3:
        interval = range(k-3, k+4)
    else:
        interval = range(1, k+4)
    inertia = []
    for i in interval:
        kmeans = KMeans(n_clusters=i, random_state=0).fit(X)
        inertia.append(kmeans.inertia_)
    
    model = KMeans(n_clusters=k, random_state=0)
    labelss = kmeans.labels_
    clusters=pd.concat([points, pd.DataFrame({'cluster':labelss})], axis=1)
    pca = PCA(n_components = 2) 
    pcadf = pca.fit_transform(Clust) 
    pcadf = pd.DataFrame(pcadf) 
    pcadf.columns = ['PC1', 'PC2']   
    f_Df = pd.concat([pcadf, pd.DataFrame({'cluster':labelss})], axis = 1)
    plt.figure(figsize=(15,10))
    axx = sns.scatterplot(x="PC1", y="PC2", hue="cluster", data=f_Df)
    sns.lineplot(interval, inertia, marker='o', ax=ax[0, 1])
    #fig = go.Figure(data=go.Scatter(x=np.arange(1,i),y=inertia))
    #fig.update_layout(title="Inertia vs Cluster Number",xaxis=dict(range=[0,i],title="Cluster Number"),yaxis={'title':'Inertia'},annotations=[])
    plt.show()
    return model, inertia, fg

def main():
    pass

st.title('Polygon')
st.subheader('This is a simple app to cluster credit card customers in the groups')
img = Image.open("C:/Users/emrre/polydoge/doge.png")
st.image(img, width=400, use_column_width=True)
st.write("Select the cluster numbers (k parameters)")

level = st.slider("Select the level", 1, 12)
dx_train, dx_test, fg = kmeanss(level, X_train)

st.pyplot(fg)

st.write("The dataframe with the identified clusters is:")
